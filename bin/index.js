#!/usr/bin/env node

// EXAMPLE Command: ./bin/index.js -n Rob Sawyer -p Test -c Test -t Development -e robksawyer@gmail.com -i ./test/my-commits.csv -o ./test.csv

const createCsvWriter = require('csv-writer').createObjectCsvWriter;
const yargs = require("yargs");
const csv = require('csv-parser')
const fs = require('fs')

const githubLogResults = [];

const options = yargs
 .usage("Usage: -n <name>")
//  .option("n", { alias: "name", describe: "Your name", type: "string", demandOption: true })
 .option("p", { alias: "project", describe: "Project Name", type: "string", demandOption: false })
 .option("c", { alias: "client", describe: "Client Name", type: "string", demandOption: false })
 .option("t", { alias: "task", describe: "Task Name", type: "string", demandOption: false })
 .option("b", { alias: "billable", describe: "Billable", type: "string", demandOption: false })
 .option("e", { alias: "email", describe: "Email", type: "string", demandOption: true })
 .option("g", { alias: "tags", describe: "Tags", type: "string", demandOption: false })
 .option("i", { alias: "input", describe: "CSV Github Input Path", type: "string", demandOption: true })
 .option("o", { alias: "output", describe: "CSV Output Path", type: "string", demandOption: true })
 .argv;

const inputData = `
Project Settings:

Name: ${options.name}
Project: ${options.project}
Client: ${options.client}
Task: ${options.task}
Email: ${options.email}
Tags: ${options.tags}
Github Input File: ${options.input}
`;

const csvWriter = createCsvWriter({
    path: options.output,
    header: [
        {id: 'project', title: 'Project'},
        {id: 'client', title: 'Client'},
        {id: 'description', title: 'Description'},
        {id: 'task', title: 'Task'},
        {id: 'email', title: 'Email'},
        {id: 'tags', title: 'Tags'},
        {id: 'billable', title: 'Billable'},
        {id: 'start_date', title: 'Start Date'},
        {id: 'start_time', title: 'Start Time'},
        // {id: 'end_date', title: 'End Date'},
        // {id: 'end_time', title: 'End Time'},
        {id: 'duration', title: 'Duration (h)'},
    ]
});


// Read the Github log input file 
fs.createReadStream(options.input)
  .pipe(csv({
      separator: ';'
  }))
  .on('data', (data) => githubLogResults.push(data))
  .on('end', () => {
    // console.log(githubLogResults[0]);
    const records = githubLogResults.map((record, i) => {
        const left = Object.values(githubLogResults[i > 0 ? i - 1 : 0])
        const right = Object.values(record)

        const startVal = left[2]
        const endVal = right[2]

        // console.log(`Starting Time: ${startVal}`)
        // console.log(`Ending Time: ${endVal}`)

        const description = right[right.length - 1]
        // console.log(description)

        // Time adjustment
        const date1 = new Date(startVal);
        const date2 = new Date(endVal);
        const diffTime = Math.abs(date2 - date1);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
        // console.log(diffTime + " milliseconds");
        // console.log(diffDays + " days");

       
       
        const startDate = date1.getMonth() + '/' + date1.getDate() + '/' + date1.getFullYear();
        const startTime = formatAMPM(date1);
        const endDate = date2.getMonth() + '/' + date2.getDate() + '/' + date2.getFullYear();
        const endTime = formatAMPM(date2);
        // const endDate = date2.getMonth() + '/' + date2.getDate() + '/' + date2.getFullYear()

        return {
            project: options.project,
            client: options.client,
            description: description,
            task: options.task,
            email: options.email,
            tags: options.tags,
            billable: options.billable || 'Yes', // Default to billable
            start_date: padZeros(date1),
            start_time: startTime,
            // end_date: padZeros(date1),
            // end_time: endTime,
            duration: msToTime(diffTime), // Convert from ms to nice time
        }
    })
    // console.log(records)

    // Time is very specific in Clockify CSVs. If it's not formatted correctly, you'll receive the following error.
    // Unable to read the file. Time format must be "H:MM:SS AM" or "H:MM:SS PM"


    // Parse the Github logs and generate some records. 
    // Note: Duration is generated by taking the first commit and then the second commit time e.g. next commit time - prev commit time
   
    csvWriter.writeRecords(records)       // returns a promise
        .then(() => {
            console.log('Your Clockify CSV has been generated. Import via the Settings page on Clockify.');
        })
        .catch((err) => {
            console.error(err)
        });
  });


/**
 * padZeros
 * @param {*} date 
 * MM/DD/YYYY
 */
function padZeros(date) {
    return ('0' + (date.getMonth()+1)).slice(-2) + '/'
             + ('0' + date.getDate()).slice(-2) + '/'
             + date.getFullYear();
}


/**
 * formatAMPM
 * @see https://stackoverflow.com/questions/8888491/how-do-you-display-javascript-datetime-in-12-hour-am-pm-format
 * @param {*} date 
 */
function formatAMPM(date) {
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var seconds = date.getSeconds();
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; // the hour '0' should be '12'
    minutes = minutes < 10 ? '0' + minutes : minutes;
    seconds = seconds < 10 ? '0' + seconds : seconds;
    return hours + ':' + minutes + ':' + seconds + ' ' + ampm;
}

/**
 * msToTime
 * @see https://www.codegrepper.com/code-examples/delphi/convert+milliseconds+to+hours+minutes+seconds+javascript
 * @param {*} duration 
 */
function msToTime(duration) {
    var milliseconds = parseInt((duration % 1000) / 100),
        seconds = Math.floor((duration / 1000) % 60),
        minutes = Math.floor((duration / (1000 * 60)) % 60),
        hours = Math.floor((duration / (1000 * 60 * 60)) % 24);

    hours = (hours < 10) ? hours : hours;
    minutes = (minutes < 10) ? "0" + minutes : minutes;
    seconds = (seconds < 10) ? "0" + seconds : seconds;
    // milliseconds = (milliseconds < 10) ? "0" + milliseconds : milliseconds;

    return hours + ":" + minutes + ":" + seconds;
}